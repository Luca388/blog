---
layout: post
categories: OS
title: 프로세스 동기화
---
> 임계 구역   : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
- race condition
> 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는것
# 상호 배제를 위한 동기화
동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기
# 실행 순서 제어를 위한 동기화
프로세스를 올바른 순서대로 실행
# mutual exclusion (상호배제)
한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올수 없다.
# progress
임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
# bounded waiting
한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다.(임계 구역에 들어오기 위해 무한정 대기해서는 안된다.)

# 동기화 기법
## 뮤텍스 락
뮤텍스 락은 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구,다시 말해 상호 배제를 위한 동기화 도구이다
> 임계구역에 진입할수 있는지 확인하고 만약 임계구역이 잠겨있다면 계속 기다린다
- lock 전역변수
- acquire 함수 임계구역을 잠근다
- release 함수 임계구역의 잠금을 해제한다
```cpp
#include <iostream>
bool lock;
void acquire()
    {
        while(lock==1);
        lock=1;
    }
void release()
    {
        lock=0;
    }
int main(int argc,char* argv[])
    {
        acquire();
        // any code
        release();
        return 0;
    }
```
이런 대기 방식을 busy wait 라고 한다.

공유 자원이 하나일떄를 가정한 방식.
## 세마포
여러개의 공유자원이 있을떄를 상정한 방식.

공유자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구.

> binary semaphore 와 counting semaphore 가 있다

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용가능한 공유 자원의 개수)를 나타내는 전역변수 S
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
- 임계 구역 앞에서 기다리는 프로세스에 진입 신호를 주는 signal 함수
```cpp
#include <iostream>
int S;
void wait()
    {
        while(S<=0);
        S--;
    }
void signal()
    {
        S++;
    }
int main(int argc,char* argv[])
    {
        wait();
        // any code
        signal();
        return 0;
    }
```
하지만 이런 방식은 cpu의 클럭을 낭비한다.

실제로 세마포에서 사용하는 방식은 wait함수는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 pcb를 세마포를 위한 대기 큐에 집어넣는다.

그리고 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal함수를 호출하면 signal함수는 대기중인 프로세스를 대기 큐에서 제거하고,프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨준다.
```cpp
#include <iostream>
int S;
void wait()
    {
        S--;
        if(S<0)
            {
                add this process to Queue;
                sleep();
            }
    }
void signal()
    {
        S++;
        if(S<=0)
            {
                remove a process p from Queue;
                wakeup(p);
            }
    }
int main(int argc,char* argv[])
    {
        wait();
        // any code
        signal();
        return 0;
    }
```

세마포를 이용해 프로세스의 순서를 제어하는 방법은 
>세마포의 변수 S를 0 으로 두고 먼저 실행할 프로세스 뒤에 signal 함수 ,그 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.
```cpp
p1              p2
//임계구역      
                wait()
signal();     //임계구역
```
## 모니터
공유자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리한다.

모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고,큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다.

즉,모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고,모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다.

모니터는 실행순서 제어를 위한 동기화도 제공하는데,특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 조건 변수를 사용한다.

조건 변수로는 wait 와 signal 연산을 수행할수 있다 wait은 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산이다

모니터에 진입한 어떤 프로세스가 x.wait()을 통해 조건변수 x에 대한 wait를 호출했다고 가정하면 그 프로세스는 조건변수 x에 대한 큐에 삽입되므로 모니터는 다시 비게 된다. 그렇기에 다른 프로세스가 모니터 안에 들어갈수 있게된다.

wait연산으로 일시 중지된 프로세스는 다른 프로세스의 signal연산을 통해 실행이 재개 될 수이 있다.즉 , signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산이다.