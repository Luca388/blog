---
layout: post
categories: CA
title: 빅 엔디안(Big-endian)과 리틀 엔디안(little-endian)
---
# 빅 엔디안(Big-endian) 과 리틀 엔디안(little-endian)
## 빅 엔디안
빅 엔디안은 보통 사람이 생각하는 선형방식과 같아 메모리에 저장된순서 그대로 읽을 수 있다
빅 엔디안은 낮은 주소에 데이터의 높은 바이트(MSB ; Most Significant Byte) 부터 저장하는 방식이다.
SPARC을 포함한 대부분의 RISC CPU 계열에서는 이 방식으로 데이터를 저장한다.

ex)0x12345678


![빅-엔디안](https://www.tcpschool.com/lectures/img_c_byteorder_big_endian.png)
## 리틀 엔디안
리틀 엔디안은 낮은 주소에 데이터 낮은 바이트를(LSB : Least Significant Byte) 저장하는 방식이다.
평소 사람이 생각하는 숫자와 반대방식이다.대부분의 인텔 CPU 계열에서는 이 방식으로 데이터를 저장한다.

ex)0x12345678

![리틀-엔디안](https://www.tcpschool.com/lectures/img_c_byteorder_little_endian.png)

## 특징
빅 엔디안 vs 리틀 엔디안
빅 엔디안과 리틀 엔디안 중 어느 한쪽이 다른 쪽과 비교해 압도적으로 좋거나 나쁘지는 않다고 알려져 있다. 두 방법은 서로 다른 아키텍처에서 공존하고 있다. 그러나 x86 아키텍처가 리틀 엔디안을 쓰기 때문에 오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언 방식을 사용한다. 반면, 네트워크에서는 주소를 주로 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다. 

 

빅 엔디안은 소프트웨어의 디버그를 편하게 해주는 경향이 있다. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편하기 때문이다. 

 

가산기(Adder)가 덧셈을 하는 과정을 생각하면 가장 작은 자릿수부터 큰 자릿수로 진행된다. 따라서 첫 번째 바이트가 LSB인 리틀 엔디안에서는 가산기 설계가 조금 더 단순해진다. 하지만 오늘날의 프로세서는 여러 개의 바이트를 동시에 읽어 들여 동시에 덧셈을 수행하는 구조를 갖기 때문에 두 엔디안 사이에 사실상 차이가 없다.

 

숫자의 대소 관계를 비교할 때는 빅 엔디안이 조금 더 빠를 수 있다. 숫자의 비교는 가장 큰 자릿수부터 비교하기 때문에, 첫 번째 바이트가 MSB인 빅 엔디안에 대소 관계 비교는 조금 더 빠를 수 있다. 



# reference
[참고](https://code-lab1.tistory.com/179)
